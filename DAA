#DAA exp1: Write a program non-recursive and recursive program to calculate Fibonacci numbers
#and analyze their time and space complexity.		
#In this code step count it calculated but not given in problem statement of our ICEM DAA index
def fibonacci_iter(n):
    if n < 0:
        return -1, 1
    if n == 0 or n == 1:
        return n, 1
    steps = 0
    a = 0
    b = 1
    print("Iterative series:", a, b, end=" ")
    for i in range(2, n + 1):
        c = a + b
        print(c, end=" ")
        a = b
        b = c
        steps += 1
    print()  # new line after series
    return c, steps  # removed +1


def fibonacci_recur(n):
    if n < 0:
        return -1, 1
    if n == 0 or n == 1:
        return n, 1
    fib1, steps1 = fibonacci_recur(n - 1)
    fib2, steps2 = fibonacci_recur(n - 2)
    return fib1 + fib2, steps1 + steps2 + 1


def print_recursive_series(n):
    print("Recursive series:", end=" ")
    for i in range(n + 1):
        print(fibonacci_recur(i)[0], end=" ")
    print()


if __name__ == '__main__':
    n = int(input("Enter a number: "))
    fib_iter, steps_iter = fibonacci_iter(n)
    print("Iterative:", fib_iter)
    print("Steps:", steps_iter)

    print_recursive_series(n)
    fib_recur, steps_recur = fibonacci_recur(n)
    print("Recursive:", fib_recur)
    print("Steps:", steps_recur)


import heapq

class Node:
    def __init__(self, ch, freq):
        self.ch = ch
        self.freq = freq
        self.left = None
        self.right = None

    def __lt__(self, other):
        return self.freq < other.freq

# Recursive function to print Huffman Codes
def print_codes(root, code=""):
    if root is None:
        return
    if not root.left and not root.right:
        print(f"{root.ch} : {code}")
        return
    print_codes(root.left, code + "0")
    print_codes(root.right, code + "1")

# Build Huffman Tree
def build_huffman(chars, freqs):
    heap = [Node(chars[i], freqs[i]) for i in range(len(chars))]
    heapq.heapify(heap)

    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        new_node = Node('-', left.freq + right.freq)
        new_node.left = left
        new_node.right = right
        heapq.heappush(heap, new_node)

    print("\nHuffman Codes:")
    print_codes(heap[0])

# Main part
n = int(input("Enter number of characters: "))
chars = input("Enter characters (no spaces): ").strip()
freqs = list(map(int, input("Enter their frequencies: ").split()))

build_huffman(list(chars), freqs)


#DAA exp3: Write a program to solve a fractional Knapsack problem using a greedy method.		

class Item:
    def __init__(self, profit, weight):
        self.profit = profit
        self.weight = weight

    # Define a function to calculate profit/weight ratio
    def ratio(self):
        return self.profit / self.weight


def fractionalKnapsack(capacity, items):
    # Sort items by ratio (profit per weight) in descending order
    items.sort(key=Item.ratio, reverse=True)

    totalValue = 0.0

    for item in items:
        if capacity >= item.weight:
            totalValue += item.profit
            capacity -= item.weight
        else:
            totalValue += item.profit * (capacity / item.weight)
            break

    return totalValue


# ---- Main Program ----
if __name__ == "__main__":
    n = int(input("Enter number of items: "))
    items = []

    for i in range(n):
        profit = int(input(f"Enter profit of item {i + 1}: "))
        weight = int(input(f"Enter weight of item {i + 1}: "))
        items.append(Item(profit, weight))

    capacity = int(input("Enter capacity of knapsack: "))

    print("Maximum value in knapsack:", fractionalKnapsack(capacity, items))



# DAA exp4: "Write a program to solve a 0-1 Knapsack problem using dynamic programming or
#branch and bound strategy."	
	
def knapsack_01(n, values, weights, W):
    dp = [[0] * (W+1) for _ in range(n+1)]

    for i in range(n+1):
        for w in range(W+1):
            if i == 0 or w == 0:
                dp[i][w] = 0
            elif weights[i-1] <= w:
                dp[i][w] = max(dp[i-1][w], dp[i-1][w-weights[i-1]] + values[i-1])
            else:
                dp[i][w] = dp[i-1][w]
    
    selected_items = []
    i, w = n, W
    while i > 0 and w > 0:
        if dp[i][w] != dp[i-1][w]:
            selected_items.append(i-1)
            w -= weights[i-1]
        i -= 1
    
    return dp[n][W], selected_items

if __name__ == "__main__":
    n = 3
    values = [60, 100, 120]
    weights = [10, 20, 30]
    W = 50

    max_value, selected_items = knapsack_01(n, values, weights, W)
    print("Maximum value:", max_value)
    print("Selected items:", selected_items)



N=8
pos=[-1]* N
pos[0]=0

def is_safe(row,col):
    for r in range(row):
        c=pos[r]
        if c==col or abs(c-col) == abs(r-row):
            return False
    return True

def solve(row=1):
    if row==N:
        for r in range(N):
            print(" ".join("Q" if pos[r]==c else "." for c in range(N)))
        return True
    for col in range(N):
        if is_safe(row,col):
            pos[row]=col 
            if solve(row+1): return True
            pos[row]=-1
    return False
    

solve()


